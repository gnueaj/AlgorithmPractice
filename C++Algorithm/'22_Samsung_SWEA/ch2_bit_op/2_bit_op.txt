ㆍ파일 입출력
freopen("sample_input.txt", "r", stdin)

ㆍ비트 연산
1. 1 << n
- 2^n의 값을 가짐
- Power set (모든 부분 집합): 각 원소가 포함되거나 포함되지 않는 경우의 수를 계산

2. i & (1 << j)
- i의 j번째 비트가 1인지 아닌지 계산
void printBits(char n)
{
    for (int i = 7; i >= 0; --i)
    {
        if (n & (i << i)) printf("1");
        else printf("0");
    }
}

ㆍBit를 이용한 부분 집합 생성
void printSubsets(char arr[], int n){
    for(int i = 0; i < (1 << n); ++i){ // 0 ~ 111...1 
        printf("{");
        for(int j = 0; j < n; ++j){
            if(i & (1 << j))
                printf("%c ", arr[j]);
        }
    }
}

3. 우선 순위
- 일반적으로 사용하는 사칙연산 +,-,*,/은 비교, 논리 연산자(==, >, && 등)보다 우선순위가 높음
- 비트 연산은 논리 연산보다 우선순위가 높으나 비교 연산보단 낮음
  if (x & y == 0) // if (x & (y == 0))과 같음

4. 응용
1) & AND, | OR
- 비트 집합 두 개를 AND하면 교집합, OR하면 합집합을 구할 수 있음.

2) ^ XOR
- true/false를 번갈아 바꾸는 스위치 구현
- 어떤 수에서 몇 개의 bit를 바꿔서 대응되는 수를 구할 수 있음(ASCII 코드)
char case_convert(char alphabet) {
	return alphabet ^ 32;
}
- 같은 값끼리 XOR하면 0이다는 특징은 많은 곳에 적용할 수 있음
  각 변이 x축 또는 y축에 평행한 직사각형의 남은 한 점의 좌표는 (x0 ^ x1 ^ x2, y0 ^ y1 ^ y2)

3) ~ NOT
- 비트 집합에 사용하면 가지고 있지 않은 원소들을 구할 수 있음
- 음의 인덱스로 사용할 수 있음

// 앞에서부터 i번째 원소와 뒤에서부터 i번째 원소를 출력하는 코드
std::vector< int > vec {0, 1, 2, 3, 4};
for (size_t i = 0; i < vec.size(); ++i) {
	printf("%d %d\n", vec.begin()[i], vec.end()[~i]);
}

4) <<, >> shift
- 2의 거듭제곱 곱셈/나눗셈
- 정수 자료형을 왼쪽으로 i칸 밀거나 오른쪽으로 i칸 미는 연산은 2^i를 곱하거나 2^i로 나누는 연산과 같음 
- 특히 / 연산은 느리므로 나누는 수가 2의 거듭제곱일 경우 >>로 바꾸면 성능 향상을 얻을 수 있음
- %(나머지) 연산도 나누는 수가 2의 제곱수일 경우 &로 바꿀 수 있음

ㆍ비트마스킹
- 각 Bit를 하나의 Flag로 활용한다면 자료 저장과 집합 표현을 쉽게 할 수 있음
ex) 사람에 0~31 사이의 번호가 매겨져 있고, 
    사람 A의 친구 목록이 {0, 3, 6, 7, 10, 28}이고, B의 친구 목록이 {0, 1, 5, 6, 17, 21, 28} 이라고 하자.
    이 때 다음과 같은 문제를 풀어봅시다.
    1) A와 B가 모두 아는 친구는?
    2) A 또는 B가 아는 친구는?

    비트로 친구 목록을 저장하면 앞의 두 문제를 빠르게 해결할 수 있음
    1)번 문제는 두 친구목록을 & 연산해 구할 수 있고 2)번 문제는 | 연산해 구할 수 있음

ㆍ데이터 압축
- 문자열 두 개를 비교하는 데에는 O(문자열의 길이)의 시간이 듬 
- 만약 사용하는 문자의 가짓수가 적다면 필요한 bit만 골라내서 정수형 자료형에 압축할 수 있음
- 문자열이 알파벳 대문자로만 이루어졌다면 구분하는 데에 1이상 26이하의 값만 필요하고, 5bits 만으로도 표현할 수 있음
- 이렇게 압축된 정수의 대소 비교 결과는 원래 문자열의 사전순 비교 결과와 같습니다.

// 12자 이내의 알파벳 대문자 문자열을 하나의 long long 변수에 압축
// WARNING 문자열의 끝(‘\0’) 이후에도 전부 ‘\0’으로 채워져 있어야 함
long long compress(char str[13]) {
	long long res = 0;
	for (size_t i = 0; i < 12; ++i) {
		res = (res << 5) | (str[i] ^ 64);
	}
	return res;
}

- 비트 1로 만들기: number |= 1 << x;
- 비트 0으로 만들기: number &= ~(1<<x);
- x번째 비트 알아내기: (number >> x ) & 1;
- x가 포함되어 있는지 검사: number & (1 << x)
- toggle: number ^= 1 << x;